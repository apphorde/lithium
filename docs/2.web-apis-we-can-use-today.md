# Web API's we can use today

We have quite a few things to put together before we can fully use the web platform. Here are some of the API's we will explore:

- Custom Elements Registry
- Templates and Slots
- ES Modules
- adopted CSS Stylesheets
- Import Maps
- Abort Controllers
- Shadow DOM and ElementInternals
- CSS parts selector

We will also build on top of concepts previously defined by projects like Angular, VueJS, SolidJS and React.

- Ref
- data binding
- props
- API Composition
- Functional components
- Redux/Store pattern

## Controlling The Context

Historically, a web page has a shared context, sometimes called "global", where bits of a page must coexist.
When pages were just a bunch of text with barely any Javascript, this was enough.

But the Web evolved, and more complex structured became harder and harder to maintain with a global context.
We need _something_ in a page to create local variables, declare event handlers, load modules and manage state.
We should also compose pieces of logic without assigning values to the `window` object.

Another problem area is styling: we don't want global styles applied everywhere. Sometimes styles must be scoped to a single component.

[Custom Elements](https://developer.mozilla.org/en-US/docs/Web/API/Web_components) are one of the building blocks we need to achieve just that.
We declare a custom `<any-name>` tag and let the platform initialize it for us. Inside that context, we can import modules, load stylesheets and run our business completely isolated from the global state.

## Declaring Components In HTML

The [`<template>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template) provides an API to include HTML in a webpage without rendering it.

This is very useful for us: we can load components just like any other HTML content, then read their content and "hydrate" the HTML with the help of Javascript, of course.

From a `template` element we use `.contents.cloneNode()` API to clone the entire template content without modifying the original nodes.

Another important aspect of templates is that scripts and styles are not activated either. We can include a `<script>` element inside a template and later use that source [as a module](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules).

### Using `<script setup>` and `<template component>` attribute

Now that we know templates, let's expand on that API. A component can be authored in plain HTML, and even inserted into a webpage directly into the source.

Here's what we introduce _on top of the standard API_:

- add a `component` attribute to give `li3` the custom element name
- optionally, add `shadow-dom` attribute to specify [Shadow DOM](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM) API options.
- inside the template, add a `<script setup>` tag to write the component logic. In that script, use [import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules#importing_features_into_your_script) statements to load `li3` and export a default value with a `setup` function:

### UI Card example

```html
<template component="ui-card" shadow-dom="open">
  <div class="card">
    <span class="card-title">{{ title }}</span>
    <slot></slot>
  </div>
  <script setup>
    import { defineProp } from '@li3/web';
    export default function uiCard() {
      defineProp('title', '');
    }
  </script>
  <style>
    .card {
      padding: 1rem;
      margin: 1rem auto;
      border-radius: 0.5rem;
      border: 1px solid #ccc;
      background-color: white;
    }
    .card-title {
      color: #999;
      text-transform: uppercase;
      font-size: 0.75rem;
      display: inline-block;
      padding: 0 0 1rem 0;
    }
  </style>
</template>
```
